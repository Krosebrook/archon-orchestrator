import { createClientFromRequest } from 'npm:@base44/sdk@0.8.4';
import { z } from 'npm:zod@3.22.4';

/**
 * Generate Training Report
 *
 * Creates comprehensive training reports including performance analysis,
 * visualizations data, and executive summaries for stakeholder review.
 */

const InputSchema = z.object({
  job_id: z.string().optional(),
  agent_id: z.string().optional(),
  date_range: z.object({
    start: z.string(),
    end: z.string()
  }).optional(),
  report_type: z.enum(['single_job', 'agent_summary', 'comparison', 'executive']).default('single_job'),
  include_sections: z.array(z.enum([
    'summary',
    'metrics',
    'charts',
    'recommendations',
    'cost_analysis',
    'comparison_history',
    'configuration_details',
    'error_analysis'
  ])).default(['summary', 'metrics', 'charts', 'recommendations']),
  format: z.enum(['json', 'markdown', 'html']).default('json')
});

const ErrorCodes = {
  UNAUTHORIZED: 'UNAUTHORIZED',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  SERVER_ERROR: 'SERVER_ERROR'
};

function createError(code: string, message: string, hint: string | null = null, retryable = false, trace_id: string | null = null) {
  const statusMap: Record<string, number> = {
    [ErrorCodes.UNAUTHORIZED]: 401,
    [ErrorCodes.VALIDATION_ERROR]: 422,
    [ErrorCodes.NOT_FOUND]: 404
  };

  return Response.json({
    code,
    message,
    hint,
    retryable,
    trace_id
  }, { status: statusMap[code] || 500 });
}

function generateMarkdownReport(data: any): string {
  const { summary, metrics, training_history, recommendations, cost_analysis } = data;

  return `# Training Report

## Executive Summary
${summary.executive_summary}

**Report Generated:** ${new Date().toISOString()}
**Report Type:** ${summary.report_type}
**Agent:** ${summary.agent_name || 'N/A'}

---

## Key Metrics

| Metric | Value | Status |
|--------|-------|--------|
| Overall Score | ${metrics.overall_score}/100 | ${metrics.overall_score >= 80 ? 'Excellent' : metrics.overall_score >= 60 ? 'Good' : 'Needs Improvement'} |
| Final Accuracy | ${(metrics.final_accuracy * 100).toFixed(2)}% | ${metrics.final_accuracy >= 0.9 ? 'Excellent' : 'Good'} |
| Final Loss | ${metrics.final_loss.toFixed(4)} | ${metrics.final_loss < 0.5 ? 'Low' : 'Moderate'} |
| Training Duration | ${Math.round(metrics.training_time_ms / 60000)} minutes | - |
| Epochs Completed | ${metrics.epochs_completed} | - |

---

## Training History

${training_history.length > 0 ? `
| Session | Accuracy | Loss | Date |
|---------|----------|------|------|
${training_history.slice(0, 10).map((h: any, i: number) =>
    `| ${i + 1} | ${(h.accuracy * 100).toFixed(1)}% | ${h.loss.toFixed(4)} | ${h.date} |`
  ).join('\n')}
` : 'No training history available.'}

---

## Recommendations

${recommendations.map((r: any, i: number) =>
    `### ${i + 1}. ${r.title}
**Priority:** ${r.priority}
**Category:** ${r.category}

${r.description}

**Expected Impact:** ${r.expected_impact}
`).join('\n')}

---

## Cost Analysis

- **Total Training Cost:** $${cost_analysis.total_cost.toFixed(4)}
- **Cost per Epoch:** $${cost_analysis.cost_per_epoch.toFixed(4)}
- **Token Usage:** ${cost_analysis.total_tokens.toLocaleString()} tokens
- **Compute Hours:** ${cost_analysis.compute_hours.toFixed(2)} hours

---

*Generated by Archon Orchestrator Training System*
`;
}

function generateHTMLReport(data: any): string {
  const { summary, metrics, recommendations } = data;

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Training Report - ${summary.agent_name || 'Agent'}</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 1200px; margin: 0 auto; padding: 2rem; background: #0f172a; color: #e2e8f0; }
    h1 { color: #f1f5f9; border-bottom: 2px solid #3b82f6; padding-bottom: 0.5rem; }
    h2 { color: #94a3b8; margin-top: 2rem; }
    .card { background: #1e293b; border-radius: 8px; padding: 1.5rem; margin: 1rem 0; border: 1px solid #334155; }
    .metric { display: inline-block; padding: 1rem 2rem; background: #0f172a; border-radius: 8px; margin: 0.5rem; }
    .metric-value { font-size: 2rem; font-weight: bold; color: #3b82f6; }
    .metric-label { font-size: 0.875rem; color: #94a3b8; }
    .recommendation { background: #1e293b; padding: 1rem; margin: 0.5rem 0; border-left: 4px solid #3b82f6; }
    .high { border-left-color: #ef4444; }
    .medium { border-left-color: #f59e0b; }
    .low { border-left-color: #10b981; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #334155; }
    th { background: #0f172a; }
  </style>
</head>
<body>
  <h1>Training Report</h1>
  <p><strong>Generated:</strong> ${new Date().toISOString()}</p>
  <p><strong>Agent:</strong> ${summary.agent_name || 'N/A'}</p>

  <h2>Executive Summary</h2>
  <div class="card">
    <p>${summary.executive_summary}</p>
  </div>

  <h2>Key Metrics</h2>
  <div class="card">
    <div class="metric">
      <div class="metric-value">${metrics.overall_score}</div>
      <div class="metric-label">Overall Score</div>
    </div>
    <div class="metric">
      <div class="metric-value">${(metrics.final_accuracy * 100).toFixed(1)}%</div>
      <div class="metric-label">Accuracy</div>
    </div>
    <div class="metric">
      <div class="metric-value">${metrics.final_loss.toFixed(4)}</div>
      <div class="metric-label">Loss</div>
    </div>
    <div class="metric">
      <div class="metric-value">${Math.round(metrics.training_time_ms / 60000)}m</div>
      <div class="metric-label">Duration</div>
    </div>
  </div>

  <h2>Recommendations</h2>
  ${recommendations.map((r: any) => `
    <div class="recommendation ${r.priority}">
      <strong>${r.title}</strong> (${r.priority} priority)
      <p>${r.description}</p>
      <small>Expected Impact: ${r.expected_impact}</small>
    </div>
  `).join('')}

  <footer style="margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #334155; color: #64748b;">
    <p>Generated by Archon Orchestrator Training System</p>
  </footer>
</body>
</html>`;
}

Deno.serve(async (req) => {
  const trace_id = crypto.randomUUID();
  const report_id = crypto.randomUUID();
  const startTime = Date.now();

  try {
    const base44 = createClientFromRequest(req);
    const user = await base44.auth.me();

    if (!user) {
      return createError(
        ErrorCodes.UNAUTHORIZED,
        'Authentication required',
        'Please authenticate to access this endpoint',
        false,
        trace_id
      );
    }

    // Validate input
    const body = await req.json();
    const validation = InputSchema.safeParse(body);

    if (!validation.success) {
      return createError(
        ErrorCodes.VALIDATION_ERROR,
        validation.error.errors[0].message,
        'Check your request parameters',
        false,
        trace_id
      );
    }

    const { job_id, agent_id, date_range, report_type, include_sections, format } = validation.data;

    // Validate we have either job_id or agent_id
    if (!job_id && !agent_id) {
      return createError(
        ErrorCodes.VALIDATION_ERROR,
        'Either job_id or agent_id is required',
        'Provide a specific job or agent to generate report for',
        false,
        trace_id
      );
    }

    let targetJobs: any[] = [];
    let agent: any = null;

    // Fetch data based on report type
    if (job_id) {
      const jobs = await base44.entities.TrainingJob.filter({ id: job_id });
      if (!jobs || jobs.length === 0) {
        return createError(
          ErrorCodes.NOT_FOUND,
          'Training job not found',
          'Verify the job_id',
          false,
          trace_id
        );
      }
      targetJobs = jobs;

      const agents = await base44.entities.Agent.filter({ id: jobs[0].agent_id });
      agent = agents?.[0];
    } else if (agent_id) {
      const agents = await base44.entities.Agent.filter({ id: agent_id });
      if (!agents || agents.length === 0) {
        return createError(
          ErrorCodes.NOT_FOUND,
          'Agent not found',
          'Verify the agent_id',
          false,
          trace_id
        );
      }
      agent = agents[0];

      // Fetch all training jobs for agent
      targetJobs = await base44.entities.TrainingJob.filter(
        { agent_id, status: 'completed' },
        '-completed_at',
        20
      ) || [];
    }

    // Build report sections
    const reportSections: any = {};

    // Summary section
    if (include_sections.includes('summary')) {
      const latestJob = targetJobs[0];

      // Generate AI summary
      const summaryPrompt = `Generate an executive summary for this training report:

Agent: ${agent?.name || 'Unknown'}
Jobs Analyzed: ${targetJobs.length}
Report Type: ${report_type}

Latest Training Results:
- Accuracy: ${latestJob?.results?.final_accuracy}
- Loss: ${latestJob?.results?.final_loss}
- Training Type: ${latestJob?.config?.trainingType}
- Duration: ${latestJob?.results?.total_training_time_ms}ms

Historical Performance (last ${targetJobs.length} sessions):
${targetJobs.slice(0, 5).map((j: any, i: number) =>
        `Session ${i + 1}: Accuracy ${j.results?.final_accuracy?.toFixed(4)}, Loss ${j.results?.final_loss?.toFixed(4)}`
      ).join('\n')}

Provide a concise 2-3 paragraph executive summary highlighting key achievements, trends, and areas needing attention.`;

      const summaryResponse = await base44.integrations.Core.InvokeLLM({
        prompt: summaryPrompt,
        response_json_schema: {
          type: "object",
          properties: {
            executive_summary: { type: "string" },
            key_highlights: { type: "array", items: { type: "string" } },
            attention_items: { type: "array", items: { type: "string" } },
            trend_direction: { type: "string", enum: ["improving", "stable", "declining"] }
          }
        }
      });

      reportSections.summary = {
        agent_name: agent?.name,
        agent_id: agent?.id,
        report_type,
        jobs_analyzed: targetJobs.length,
        date_generated: new Date().toISOString(),
        ...summaryResponse
      };
    }

    // Metrics section
    if (include_sections.includes('metrics')) {
      const latestJob = targetJobs[0];
      reportSections.metrics = {
        overall_score: Math.round(((latestJob?.results?.final_accuracy || 0) * 100 + (1 - (latestJob?.results?.final_loss || 1)) * 100) / 2),
        final_accuracy: latestJob?.results?.final_accuracy || 0,
        final_loss: latestJob?.results?.final_loss || 1,
        final_validation_accuracy: latestJob?.results?.final_validation_accuracy || 0,
        final_validation_loss: latestJob?.results?.final_validation_loss || 1,
        training_time_ms: latestJob?.results?.total_training_time_ms || 0,
        epochs_completed: latestJob?.results?.epochs_completed || 0,
        best_accuracy: Math.max(...targetJobs.map((j: any) => j.results?.final_accuracy || 0)),
        best_loss: Math.min(...targetJobs.filter((j: any) => j.results?.final_loss).map((j: any) => j.results?.final_loss)),
        average_accuracy: targetJobs.reduce((sum: number, j: any) => sum + (j.results?.final_accuracy || 0), 0) / targetJobs.length,
        total_training_sessions: targetJobs.length
      };
    }

    // Charts data section
    if (include_sections.includes('charts')) {
      reportSections.charts = {
        accuracy_over_time: targetJobs.map((j: any) => ({
          date: j.completed_at,
          accuracy: j.results?.final_accuracy,
          validation_accuracy: j.results?.final_validation_accuracy
        })).reverse(),
        loss_over_time: targetJobs.map((j: any) => ({
          date: j.completed_at,
          loss: j.results?.final_loss,
          validation_loss: j.results?.final_validation_loss
        })).reverse(),
        training_duration: targetJobs.map((j: any) => ({
          date: j.completed_at,
          duration_minutes: (j.results?.total_training_time_ms || 0) / 60000
        })).reverse(),
        configuration_comparison: targetJobs.slice(0, 5).map((j: any) => ({
          job_id: j.id,
          config: j.config,
          accuracy: j.results?.final_accuracy,
          loss: j.results?.final_loss
        }))
      };
    }

    // Recommendations section
    if (include_sections.includes('recommendations')) {
      const latestJob = targetJobs[0];

      const recPrompt = `Based on this training data, provide specific recommendations:

Latest Results: Accuracy ${latestJob?.results?.final_accuracy}, Loss ${latestJob?.results?.final_loss}
Configuration: ${JSON.stringify(latestJob?.config)}
Sessions: ${targetJobs.length}
Trend: ${targetJobs.length > 1 ?
          (targetJobs[0]?.results?.final_accuracy > targetJobs[1]?.results?.final_accuracy ? 'improving' : 'declining') :
          'unknown'}

Provide 3-5 actionable recommendations.`;

      const recResponse = await base44.integrations.Core.InvokeLLM({
        prompt: recPrompt,
        response_json_schema: {
          type: "array",
          items: {
            type: "object",
            properties: {
              title: { type: "string" },
              priority: { type: "string", enum: ["high", "medium", "low"] },
              category: { type: "string" },
              description: { type: "string" },
              expected_impact: { type: "string" }
            }
          }
        }
      });

      reportSections.recommendations = recResponse;
    }

    // Cost analysis section
    if (include_sections.includes('cost_analysis')) {
      const totalTokens = targetJobs.reduce((sum: number, j: any) =>
        sum + (j.metrics?.token_usage || j.training_data?.training_samples * 150 || 0), 0);
      const totalTimeMs = targetJobs.reduce((sum: number, j: any) =>
        sum + (j.results?.total_training_time_ms || 0), 0);

      reportSections.cost_analysis = {
        total_cost: totalTokens * 0.00001, // Approximate cost per token
        cost_per_epoch: (totalTokens * 0.00001) / targetJobs.reduce((sum: number, j: any) =>
          sum + (j.results?.epochs_completed || 0), 0),
        total_tokens: totalTokens,
        compute_hours: totalTimeMs / 3600000,
        jobs_analyzed: targetJobs.length,
        average_cost_per_job: (totalTokens * 0.00001) / targetJobs.length
      };
    }

    // Training history section
    if (include_sections.includes('comparison_history')) {
      reportSections.training_history = targetJobs.map((j: any) => ({
        job_id: j.id,
        accuracy: j.results?.final_accuracy,
        loss: j.results?.final_loss,
        date: j.completed_at,
        training_type: j.config?.trainingType,
        epochs: j.results?.epochs_completed,
        duration_ms: j.results?.total_training_time_ms
      }));
    }

    // Configuration details section
    if (include_sections.includes('configuration_details')) {
      reportSections.configuration_details = {
        latest_config: targetJobs[0]?.config,
        config_history: targetJobs.slice(0, 10).map((j: any) => ({
          job_id: j.id,
          config: j.config,
          date: j.completed_at
        }))
      };
    }

    // Build final report
    const reportData = {
      report_id,
      ...reportSections,
      generated_at: new Date().toISOString(),
      generated_by: user.id
    };

    // Store report
    await base44.asServiceRole.entities.TrainingReport.create({
      id: report_id,
      agent_id: agent?.id,
      job_ids: targetJobs.map((j: any) => j.id),
      report_type,
      sections: include_sections,
      data: reportData,
      format,
      generated_at: new Date().toISOString(),
      org_id: user.organization.id
    });

    // Audit log
    await base44.asServiceRole.entities.Audit.create({
      entity_type: 'training_report',
      entity_id: report_id,
      action: 'report_generated',
      metadata: {
        report_type,
        agent_id: agent?.id,
        jobs_count: targetJobs.length,
        format,
        trace_id
      },
      org_id: user.organization.id
    });

    const latency = Date.now() - startTime;

    // Telemetry
    console.log(JSON.stringify({
      event: 'training_report_generated',
      trace_id,
      report_id,
      report_type,
      format,
      agent_id: agent?.id,
      jobs_count: targetJobs.length,
      latency_ms: latency,
      org_id: user.organization.id
    }));

    // Format output
    let output: any;
    if (format === 'markdown') {
      output = generateMarkdownReport(reportData);
    } else if (format === 'html') {
      output = generateHTMLReport(reportData);
    } else {
      output = reportData;
    }

    return Response.json({
      success: true,
      data: {
        report_id,
        format,
        content: output
      },
      trace_id
    }, { status: 200 });

  } catch (error) {
    console.error(JSON.stringify({
      event: 'generate_training_report_error',
      trace_id,
      error: error.message,
      stack: error.stack
    }));

    return createError(
      ErrorCodes.SERVER_ERROR,
      'Failed to generate training report',
      'Please try again or contact support if the issue persists',
      true,
      trace_id
    );
  }
});
